#!/usr/bin/env python3
"""
ü§ñ BOT DE TRADING INTRAD√çA EN VIVO - VERSI√ìN CORREGIDA
======================================================

Bot completo con:
- WebSocket en tiempo real 
- Se√±ales de trading intrad√≠a
- Price targets
- Alertas de precauci√≥n
- Precios de entrada optimizados
"""

import asyncio
import sys
import logging
from pathlib import Path
from datetime import datetime
import json

# A√±adir src al path
sys.path.append(str(Path(__file__).parent))

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

from data_sources.binance_websocket_aggregator import BinanceWebSocketAggregator
from strategies.intraday_trading_signals import IntradayTradingSignals
from ml_models.price_target_predictor import PriceTargetPredictor

# Mock config para el bot
class BotConfig:
    def get(self, key, default=None):
        configs = {
            'data_aggregator.min_volume_24h': 5000000,  # $5M+ volumen
            'data_aggregator.max_pairs': 10,  # Top 10 pares
            'data_aggregator.update_interval': 1
        }
        return configs.get(key, default)

class LiveIntradayBot:
    """Bot de trading intrad√≠a en tiempo real corregido"""
    
    def __init__(self):
        self.config = BotConfig()
        self.aggregator = None
        self.signals = IntradayTradingSignals()
        self.predictor = PriceTargetPredictor()
        self.is_running = False
        
        # Estad√≠sticas
        self.processed_count = 0
        self.signals_generated = 0
        self.start_time = None
        
        # Cache de datos recientes
        self.price_cache = {}
        
    def display_banner(self):
        """Banner de inicio"""
        print("\n" + "="*70)
        print("ü§ñ LIVE INTRADAY TRADING BOT - CORREGIDO")
        print("="*70)
        print("üìä Trading intrad√≠a con datos en vivo")
        print("‚ö° WebSocket en tiempo real")
        print("üéØ Se√±ales de entrada optimizadas") 
        print("‚ö†Ô∏è  Alertas de precauci√≥n integradas")
        print("üí∞ Price targets autom√°ticos")
        print("="*70 + "\n")
        
    async def on_price_update(self, symbol, ticker_data):
        """Procesa actualizaciones de precio en tiempo real"""
        try:
            self.processed_count += 1
            
            # Extraer datos del ticker
            price = float(ticker_data.price)
            volume = float(ticker_data.volume_24h)
            change = float(ticker_data.change_24h)
            high = float(ticker_data.high_24h)
            low = float(ticker_data.low_24h)
            
            # Actualizar cache
            self.price_cache[symbol] = {
                'price': price,
                'volume': volume,
                'change': change,
                'high': high,
                'low': low,
                'timestamp': datetime.now()
            }
            
            # Mostrar precios cada 20 actualizaciones
            if self.processed_count % 20 == 0:
                self.display_price_update(symbol, price, change, volume)
            
            # Generar se√±al si hay suficiente volumen
            if volume > 5000000:  # $5M+
                await self.analyze_trading_opportunity(symbol, ticker_data)
                
        except Exception as e:
            logging.error(f"Error procesando {symbol}: {e}")
            
    def display_price_update(self, symbol, price, change, volume):
        """Muestra actualizaci√≥n de precio formateada"""
        change_color = "üìà" if change >= 0 else "üìâ"
        print(f"{change_color} {symbol}: ${price:,.4f} ({change:+.2f}%) Vol: ${volume:,.0f}")
        
    async def analyze_trading_opportunity(self, symbol, ticker_data):
        """Analiza oportunidad de trading"""
        try:
            # Preparar datos para an√°lisis
            market_data = {
                'symbol': symbol,
                'current_price': float(ticker_data.price),
                'volume_24h': float(ticker_data.volume_24h),
                'price_change_24h': float(ticker_data.change_24h),
                'high_24h': float(ticker_data.high_24h),
                'low_24h': float(ticker_data.low_24h),
                'timestamp': datetime.now()
            }
            
            # Generar se√±al de trading
            signal = await self.signals.generate_signal(market_data)
            
            if signal and signal.get('signal_strength', 0) > 65:
                self.signals_generated += 1
                await self.display_trading_signal(symbol, signal, market_data)
                
                # Calcular price target
                target = await self.predictor.calculate_price_target(market_data)
                if target:
                    self.display_price_target(symbol, target)
                    
        except Exception as e:
            logging.error(f"Error analizando {symbol}: {e}")
            
    async def display_trading_signal(self, symbol, signal, market_data):
        """Muestra se√±al de trading formateada"""
        print(f"\nüö® SE√ëAL DE TRADING #{self.signals_generated}")
        print(f"{'='*50}")
        print(f"üìä Par: {symbol}")
        print(f"üí∞ Precio actual: ${market_data['current_price']:,.4f}")
        print(f"üéØ Tipo: {signal.get('signal_type', 'N/A')}")
        print(f"üí™ Fuerza: {signal.get('signal_strength', 0):.1f}%")
        print(f"‚è∞ Timeframe: {signal.get('timeframe', 'N/A')}")
        
        # Precios de entrada y salida
        if signal.get('entry_price'):
            print(f"üö™ Entrada: ${signal['entry_price']:,.4f}")
        if signal.get('stop_loss'):
            print(f"üõë Stop Loss: ${signal['stop_loss']:,.4f}")
        if signal.get('take_profit_1'):
            print(f"üéØ Take Profit 1: ${signal['take_profit_1']:,.4f}")
        if signal.get('take_profit_2'):
            print(f"üéØ Take Profit 2: ${signal['take_profit_2']:,.4f}")
            
        # Alertas de precauci√≥n
        if signal.get('precaution_alerts'):
            print(f"‚ö†Ô∏è  PRECAUCI√ìN:")
            for alert in signal['precaution_alerts'][:2]:  # Mostrar solo las primeras 2
                print(f"   ‚Ä¢ {alert}")
                
        # Informaci√≥n adicional
        if signal.get('position_size_recommended'):
            print(f"üìè Tama√±o posici√≥n: {signal['position_size_recommended']:.2%}")
        if signal.get('risk_level'):
            print(f"‚öñÔ∏è  Riesgo: {signal['risk_level']}")
            
        print(f"{'='*50}\n")
        
    def display_price_target(self, symbol, target):
        """Muestra price target"""
        print(f"üéØ PRICE TARGET - {symbol}")
        print(f"   üìà Target: ${target.get('target_price', 0):,.4f}")
        print(f"   üìä Upside: +{target.get('upside_percentage', 0):.1f}%")
        print(f"   üïê Timeframe: {target.get('timeframe', 'N/A')}")
        print(f"   üíØ Confianza: {target.get('confidence_score', 0):.1f}%\n")
        
    def display_statistics(self):
        """Muestra estad√≠sticas en tiempo real"""
        if not self.start_time:
            return
            
        elapsed = (datetime.now() - self.start_time).total_seconds()
        
        print(f"\nüìä ESTAD√çSTICAS ({elapsed:.0f}s)")
        print(f"   üì® Actualizaciones procesadas: {self.processed_count}")
        print(f"   üö® Se√±ales generadas: {self.signals_generated}")
        print(f"   üìà Pares activos: {len(self.price_cache)}")
        print(f"   ‚ö° Rate: {self.processed_count/elapsed:.1f} updates/seg")
        
        # Mostrar top 3 pares por volumen
        if self.price_cache:
            sorted_pairs = sorted(self.price_cache.items(), 
                                key=lambda x: x[1]['volume'], reverse=True)[:3]
            print(f"   üî• Top pares por volumen:")
            for symbol, data in sorted_pairs:
                print(f"      {symbol}: ${data['volume']:,.0f}")
        print()
        
    async def run(self, duration=300):  # 5 minutos por defecto
        """Ejecuta el bot por un tiempo determinado"""
        self.display_banner()
        
        print(f"üïê Ejecutando por {duration} segundos...")
        print("üì° Conectando a datos en tiempo real...")
        
        try:
            self.is_running = True
            self.start_time = datetime.now()
            
            # Inicializar aggregator
            self.aggregator = BinanceWebSocketAggregator(self.config)
            self.aggregator.register_callback('ticker_update', self.on_price_update)
            
            # Conectar
            await self.aggregator.initialize()
            print("‚úÖ Conectado! Monitoreando mercado...\n")
            
            # Loop principal con estad√≠sticas
            for i in range(duration):
                await asyncio.sleep(1)
                
                # Mostrar estad√≠sticas cada 30 segundos
                if i > 0 and i % 30 == 0:
                    self.display_statistics()
                    
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è  Bot detenido por usuario")
        except Exception as e:
            print(f"\n‚ùå Error en bot: {e}")
            logging.error(f"Error en bot: {e}")
        finally:
            await self.stop()
            
    async def stop(self):
        """Detiene el bot"""
        self.is_running = False
        
        if self.aggregator:
            try:
                await self.aggregator.close()
                print("‚úÖ WebSocket cerrado")
            except Exception as e:
                logging.error(f"Error cerrando aggregator: {e}")
                
        # Mostrar estad√≠sticas finales
        self.display_final_summary()
        
    def display_final_summary(self):
        """Muestra resumen final"""
        print("\n" + "="*70)
        print("üìã RESUMEN DE SESI√ìN")
        print("="*70)
        
        if self.start_time:
            elapsed = (datetime.now() - self.start_time).total_seconds()
            print(f"‚è∞ Duraci√≥n: {elapsed:.0f} segundos")
            print(f"üìä Total actualizaciones: {self.processed_count}")
            print(f"üö® Se√±ales generadas: {self.signals_generated}")
            print(f"üìà Rate promedio: {self.processed_count/elapsed:.1f} updates/seg")
            
        print(f"‚úÖ Bot ejecutado exitosamente")
        print("="*70 + "\n")

async def main():
    """Funci√≥n principal"""
    bot = LiveIntradayBot()
    
    print("ü§ñ ¬øCu√°nto tiempo quieres ejecutar el bot?")
    print("1. Demo r√°pida (60 segundos)")
    print("2. Sesi√≥n corta (5 minutos)")
    print("3. Sesi√≥n media (15 minutos)")
    print("4. Sesi√≥n larga (30 minutos)")
    
    try:
        choice = input("\nElige una opci√≥n (1-4) o presiona Enter para demo: ").strip()
        
        duration_map = {
            '1': 60,
            '2': 300,
            '3': 900,
            '4': 1800
        }
        
        duration = duration_map.get(choice, 60)  # Por defecto 1 minuto
        print(f"\nüöÄ Iniciando sesi√≥n de {duration} segundos...")
        
        await bot.run(duration)
        
    except KeyboardInterrupt:
        print("\nüëã Bot cancelado por usuario")
    except Exception as e:
        print(f"\n‚ùå Error: {e}")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã Hasta luego!")
